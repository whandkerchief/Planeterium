using UnityEngine;

/*
The blob generator creates a 2D blob texture to define the shape of a star for a given input number. 
The input number is put through a murmur hash function to remap it to a random number between 0 and 1.
Using this new random decimal, a circle is defined with 5 to 45 verticies. 
The verticies of the circle is then deformed using the input number put through the murmur hash function
with an offset. 

The output is a 2D texture with a white background, and a blob shape filled in black. This is used as input
for the particle systems to create a star of the given blob shape. 
*/
public class BlobGenerator : MonoBehaviour
{
    //Main function called to generate the blob texture for a given input number
    public Texture2D GenerateBlob(int inputNumber)
    {
        Debug.Log("Blob generator: Request recieved");
        //Blob image scale
        int width = 256;
        int height = 256;

        Texture2D texture = new Texture2D(width, height);
        
        //Set background of blob texture as white
        Color[] pixels = new Color[width * height];
        for (int i = 0; i < pixels.Length; i++) pixels[i] = Color.white;
        texture.SetPixels(pixels);

        //Define shape properties
        int numPoints = 5 + (int)(Murmur(inputNumber, 0) * 40);
        Vector2[] points = new Vector2[numPoints];
        Vector2 center = new Vector2(width / 2, height / 2);
        int baseSize = 80;

        // Generate random points and deform verticies based on a random number generated by the hashed input number 
        for (int i = 0; i < numPoints; i++)
        {
            float angle = (i * Mathf.PI * 2) / numPoints;
            float radiusMultiplier = 0.2f + Murmur(inputNumber, i + 3) * 1.3f; // 0.6 to 1.4
            float radius = baseSize * radiusMultiplier;
            points[i] = new Vector2(center.x + Mathf.Cos(angle) * radius, center.y + Mathf.Sin(angle) * radius);
        }

        // Draw the shape on the texture
        DrawBlob(texture, points);

        // Apply the changes to the texture
        texture.Apply();
        return texture;
    }

    //Murmur hash function
    private static float Murmur(int input, int offset)
    {
        uint hash = (uint)(input ^ (offset * 0x5bd1e995));
        hash = (hash ^ (hash >> 15)) * 0x5bd1e995;
        return (hash & 0x7FFFFFFF) / (float)int.MaxValue;
    }

    //Draws the blob shape on the given texture using the generated points
    private void DrawBlob(Texture2D texture, Vector2[] points)
    {
        int width = texture.width;
        int height = texture.height;

        //Fill algorithm that checks if a pixel is within the shape defined by points[x,y] and colours the pixel black if true
        for (int x = 0; x < width; x++)
        {
            for (int y = 0; y < height; y++)
            {
                if (IsPointInsideBlob(new Vector2(x, y), points))
                {
                    texture.SetPixel(x, y, Color.black); // Inside the blob, set to black
                }
                else
                {
                    texture.SetPixel(x, y, Color.white); // Outside, leave white
                }
            }
        }
    }

    // Checks if a point (x, y) is inside the blob defined by the points using simple 2D raycasting
    private bool IsPointInsideBlob(Vector2 point, Vector2[] points)
    {
        int j = points.Length - 1;
        bool inside = false;
        //iterate through edges and find the edge where point.y lies in. 
        for (int i = 0; i < points.Length; i++)
        {
            // Check if the point's y-coordinate is between the y-values of the current edge 
            if ((points[i].y > point.y) != (points[j].y > point.y) &&
                // Check if the point is to the left of the intersection point of the edge with the ray
                (point.x < (points[j].x - points[i].x) * (point.y - points[i].y) / (points[j].y - points[i].y) + points[i].x))
            {
                //if the ray intersects the edge once, its inside
                inside = !inside;
            }
            j = i;
        }
        return inside;
    }
}
